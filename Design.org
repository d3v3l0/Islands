#+TITLE Islands Design
#+STARTUP: indent

* TCOD Python Wrapper
** Fast Console/Window Objects
Want to treat TCODS console as numpy array:

#+BEGIN_SRC ipython :session
  import tcod.console

  c = tcod.console(80,80)
  c.foreground[10, 10]
  c.background[0,0]
  c.char[5, 5]
  c.flush()
#+END_SRC
* Representing the World
** Logical Representation

Some initial thoughts on data structures:

First design rule — NO INFINITE WORLDS. Multiple worlds are okay, but
an infinite world is going to make sophisticated AI difficult, I
think.

The idea of breaking world data into „chunks“ seems
reasonable. Playing with chunk sizes should allow one to balance space
and speed. My only concern is how to stitch together adjacent
chunks. There needs to be some sort of smoothing function to eliminate
abrupt transitions between chunks.

Terrain squares in a chunk or defined by:
 — Height
 — temperature
 — ground moisture (1 for water, 0 rock)
 — ground type
 — foliage types
 — foliage density?

In general the higher up you are on the map the drier the soil/ground
will be. Also ground and height together will determine the allowable
ground types for a given terrain square.

Tcod has tools for generating height apps and, I believe, erosion
maps.

Can use tcod to generate a height map, but there won't be a 1-1
correspondence between height+moisture values and terrain
squares. Rather a height+moisture value will represent an NxN grid of
terrain squares.

Algorithm for generating a chunk:
 — specify height and moisture grid size.
 — specify grid square to terrain grid scaling (e.g. One grid square = 10x10 terrain squares)
 — generate height map.
 — generate ground moisture map (<— heights)
 — generate terrain map (<— heights and moistures).

Drawing implemented in multiple passes. First to draw terrain, second
for features and actors.

Structures (like homes, shops, hospitals, barracks, etc) are
represented as logical entities. That is, they are not represented
directly in the map. Instead of a large list of wall objects, for
instance, we could define a rectangle of a certain width and height,
centered at a certain (x, y) then during the drawing pass the
structure would draw the appropriate objects for walls, doors,
windows, etc.

Chunks can be stored and queried on disk, but can also be loaded
completely into memory when speed matters. For initial implementation
will only have one chunk to ease debugging optimization,

#+BEGIN_SRC ipython :session t
  class World(object):
      slots = (chunks, actors, structures, objects)

  class WorldChunk(object):
      slots = (elevations, temperatures, ground_types, ground_moistures, foliage_types, foliage_densities)

  class Feature(object):
      slots=(x, y, name, short_desc, long_desc)       
#+END_SRC

** Viewable representation

`World` object acts as a database that is queried by a `WorldView`
object, which is a subclass of `cocos.layer.ScrollableLayer,` or maybe
just `Layer`?
 
Need a Layer-like object that performs visualization operations based
on contents on an numpy array object.

For prototyping use simple 2D geometric shapes with color (and in some
cases, maybe textures) to draw everything.
