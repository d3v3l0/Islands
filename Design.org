#+TITLE Islands Design
#+STARTUP: indent

* TCOD Python Wrapper
** ConsoleBuffer: Fast Console/Window Drawing
Want to treat TCOD console as numpy array:

#+BEGIN_SRC ipython :session
  import tcod.console

  c = tcod.console(80,80)
  c.foreground[10, 10]
  c.background[0,0]
  c.char[5, 5]
  c.flush()
#+END_SRC

samples_py uses a meshgrid and three 1-D arrays for R, G, B components. Would be
more readable if there was a better way than:

#+BEGIN_SRC ipython :session
  c.background_r[0,0] = red
  c.background_g[0,0] = green
  c.background_b[0,0] = blue
#+END_SRC

Thankfully numpy is truly awesome. Check this out:

#+BEGIN_SRC ipython :session
  a = np.zeros((10,10,3))
  # Slow!
  a[0,0] = tcod.blue
  # Fast!
  a[0,0,0] = tcod.blue.r
  a[0,0,1] = tcod.blue.g
  a[0,0,2] = tcod.blue.b

  a[..., 2].ravel('F')
#+END_SRC

The second call works as expected, while the last call returns a 1-D array of
all the blue component values. Note that this is really slow since numpy has to
figure out types and do conversions. Much faster to explicitly assign the RGB
components. Also tcod seems to do array indexing by column-major format (I think
this is so that (x y) references match user expectations more closely), so the call
to ravel is adjusted accordingly.

Maybe what I want is the slow, pokey, but general Console class with a
FillConsole (or other suitably named) subclass that implements the Numpy array
details. Implementing something similar to [[file:tcod/libtcodpy.py::class%20ConsoleBuffer:][ConsoleBuffer]], except with numpy
arrays, seems smart.

** CL-Dormouse Port

Windowing/GUI system built on tcod. This is the Islands.gui module.
Islands.tcod is a slightly more pythonic wrapper around libtcodpy.

*** Classes

* Representing the World
** Treat World State as a Relational DB?
Or as arrays/linear spaces?

Or as logic programming problem?

From [[https://sites.google.com/site/pydatalog/3---datalog-and-data-integration][pydatalog]]:

#+begin_src ipython :session t
  from pyDatalog import pyDatalog
  from sqlalchemy.ext.declarative import declarative_base

  # define a base class with SQLAlchemy and pyDatalog capabilities
  Base = declarative_base(cls=pyDatalog.Mixin, metaclass=pyDatalog.sqlMetaMixin)

  from sqlalchemy import create_engine
  from sqlalchemy.orm import sessionmaker

  # create database in memory
  engine = create_engine('sqlite:///:memory:', echo=False)

  # open a session on a database, then associate it to the Base class
  Session = sessionmaker(bind=engine)
  session = Session()
  Base.session = session

#+end_src

#+RESULTS:

** Logical Representation

Some initial thoughts on data structures:

First design rule — NO INFINITE WORLDS. Multiple worlds are okay, but
an infinite world is going to make sophisticated AI difficult, I
think.

The idea of breaking world data into „chunks“ seems
reasonable. Playing with chunk sizes should allow one to balance space
and speed. My only concern is how to stitch together adjacent
chunks. There needs to be some sort of smoothing function to eliminate
abrupt transitions between chunks.

Terrain squares in a chunk or defined by:
 — Height
 — temperature
 — ground moisture (1 for water, 0 rock)
 — ground type
 — foliage types
 — foliage density?

In general the higher up you are on the map the drier the soil/ground
will be. Also ground and height together will determine the allowable
ground types for a given terrain square.

Tcod has tools for generating height apps and, I believe, erosion
maps.

Can use tcod to generate a height map, but there won't be a 1-1
correspondence between height+moisture values and terrain
squares. Rather a height+moisture value will represent an NxN grid of
terrain squares.

Algorithm for generating a chunk:
 — specify height and moisture grid size.
 — specify grid square to terrain grid scaling (e.g. One grid square = 10x10 terrain squares)
 — generate height map.
 — generate ground moisture map (<— heights)
 — generate terrain map (<— heights and moistures).

Drawing implemented in multiple passes. First to draw terrain, second
for features and actors.

Structures (like homes, shops, hospitals, barracks, etc) are
represented as logical entities. That is, they are not represented
directly in the map. Instead of a large list of wall objects, for
instance, we could define a rectangle of a certain width and height,
centered at a certain (x, y) then during the drawing pass the
structure would draw the appropriate objects for walls, doors,
windows, etc.

Chunks can be stored and queried on disk, but can also be loaded
completely into memory when speed matters. For initial implementation
will only have one chunk to ease debugging optimization,

#+BEGIN_SRC ipython :session t
  class World(object):
      slots = (chunks, actors, structures, objects)

  class WorldChunk(object):
      slots = (elevations, temperatures, ground_types, ground_moistures, foliage_types, foliage_densities)

  class Feature(object):
      slots=(x, y, name, short_desc, long_desc)       
#+END_SRC

** Viewable representation

`World` object acts as a database that is queried by a `WorldView`
object, which is a subclass of `cocos.layer.ScrollableLayer,` or maybe
just `Layer`?
 
Need a Layer-like object that performs visualization operations based
on contents on an numpy array object.

For prototyping use simple 2D geometric shapes with color (and in some
cases, maybe textures) to draw everything.

** Objects/Props/Entities
Props as in stage props. Have properties and physical presence in world, but otherwise do
not actively participate in game loop like agents do.

#+begin_src ipython :session t
  class GameProp(object):
      def __init__(self):
          pass
    
#+end_src

Lots of issues to consider here, but issue is how to make creating and editing
objects as easy as possible. Think the way we want to do this is to define
entities using org buffers.

** Agents/Actors

#+begin_src ipython :session t
  class Actor(Entity):
      def on_update(self, world_state):
          self.observe(world_state)
          self.think()
          self.act(world_state)
#+end_src

** Behaviors

How entities and actor interact with each other and the world.

Implemented as events and finite state machines.
** Defining entities through org-mode
** Polygonal Map Generation

Currently [[file:worldgen.py::class%20WorldGenerator(object):][worldgen.py]] makes heavy use of Perlin noise to generate heightmaps and
climate, etc for the world. Another way of doing this is to generate a [[http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/][polygonal
tiling]] using voronoi diagrams.

Amit's [[https://github.com/amitp/mapgen2][code]] uses Actionscript, and is based on another Actionscript [[http://nodename.github.io/as3delaunay/][library]] that
does voronoi/delauny calculations.

In the world of Python it appears that [[http://docs.scipy.org/doc/scipy-0.14.0/reference/tutorial/spatial.html][SciPy]] and [[https://github.com/materialsvirtuallab/pyhull][pyhull]] both provide
implementations of the algorithms Amit is using for map generation. They seem to
currently be roughly equivalent in terms of performance. SciPy includes many
pots and pans, so probably is not as pragmatic a choice for inclusion in a game
engine. Note, though, that current SciPy (version > 12) uses qhull to implement
the Voronoi tesselation algorithm.

Let's look at some examples using pyhull and SciPy:

#+BEGIN_SRC ipython :session t
  from pyhull.convex_hull import ConvexHull
  pts = [[-0.5, -0.5], [-0.5, 0.5], [0.5, -0.5], [0.5, 0.5], [0,0]]
  hull = ConvexHull(pts)


  from pyhull.delaunay import DelaunayTri
  tri = DelaunayTri(pts)

  from pyhull.voronoi import VoronoiTess
  v = VoronoiTess(pts)
#+END_SRC

#+BEGIN_SRC ipython :session t
  from scipy.spatial import Voronoi
  vor = Voronoi(points)
  vor.vertices
#+END_SRC

Okay, ob-ipython not working in my Linux setup (prolly 'cause ob-ipython and
conda do not play well together) so have moved the code over to an actual [[ipynb:(:url-or-port%208888%20:name%20"Islands/Polygonal%20Map%20Generation.ipynb")][notebook]].
* Modeling the world
Model the flow of currency (money/productivity)? Agents/citizens are sources,
but what would be the sinks? Banks, commodity and stock exchanges are nodes?

* References
- Never forget about Amit's [[http://www.redblobgames.com/][Red Blob Games]].
